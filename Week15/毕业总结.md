# 毕业总结

## 思维导图

![](http://img.yelizi.top/e565d10e-5264-41cf-b80c-143df1ef6524.jpg$xyz)

## 1. JVM

JVM是Java代码运行在操作系统上的关键，学习它能够提升应对系统运行时可能遇到的奇怪Bug。比如说知道了字节码是咋回事，那编译优化引起的问题就好理解；比如了解了Java内存模型，那就能清楚机器的内存搭配；
比如了解了各类GC的特点，就能在需要应对不同场景时能合理选择合适的GC；比如就是出现了奇怪的Bug，可以通过分析诸如GC日志、线程情况以及Dump出的heap总会有迹可循而不需要在那猜测，等等。
诚然，这玩意很难啃，也对直接写代码几乎谈不上提升，但想要让自己的代码运行更好，或者更直接的说想要在Java这行走的更远，必须要啃这块骨头。

## 2. NIO

谈Java NIO，首先明确这就涉及到了Socket编程，然后也要了解IO模型（这里说一下，Java NIO并不是IO模型里严格的同步非阻塞模型，它其实实现的是IO复用模型）。
由于Java NIO本身很难用，甚至可以稍微了解下原理就可以跳过直接去学一个封装它非常完美的框架--Netty。
至于说可以做什么？那先明确它是干啥的——提供更快速更高性能的网络服务。那么类似网关、RPC框架等等那在Java层面的实现那几乎都绕不开，大名鼎鼎的Dubbo就是基于Netty去做网络通信的。

## 3. 并发编程

首先明确并发是为了更好的利用多核CPU的优势从而达到提升性能的目的，并不是无脑开非常多的线程就可以提升性能。
并发编程时一定要注意判断代码是否会引发安全性问题，即可见性问题、有序性问题和原子性问题。


## 4. Spring 和 ORM 等框架

Spring和ORM框架（比如MyBatis）可以说是当下Java企业级应用开发必不可少的，它们存在的目的是为了让开发人员把更多的精力专注于业务本身。
Spring其IOC简化了开发，AOP让开发更加灵活，事务特性也是完美的支持，还有一堆衍生产品覆盖方方面面。
MyBatis单纯一点就是封装了JDBC的操作，但是避免了复杂又臃肿的JDBC编程简直功德无量。

## 5. MySQL 数据库和 SQL

MySQL是当下主流的关系型数据库之一，其几乎完美的适配了标准版SQL语法规范，有数据库原理学科经历基本都是无需额外学习都能上手。
MySQL通过将底层引擎插件化，做到可以可插拔的适配多种方案的存储，默认使用也是标准情况都能覆盖的就是InnoDB引擎。

## 6. 分库分表

MySQL的连接资源是很宝贵的，但是日益增长的并发量却不会给你面子，那没有手段，系统就可以瘫痪了。
手段一就是对数据库思考一种方式能支撑更高的并发量，那就是拆库。
最简单的拆库就是不同业务不同库（商品、库存分库），但是不能解决单业务类型的高并发问题，
于是针对单业务的表再进行分库（目的就是打散流量）。
然后就是分表，因为单表由于锁的存在也会限制并发量，于是就有了按业务垂直分表（拆子业务），再按自己本身水平分表（单纯多张表）。

## 7. RPC 和微服务

为了应对高并发量，也不能光数据库发力，系统本身也有瓶颈，集群当然最简单的方案，但有种大锅饭的感觉，而且随着系统本身和并发都日渐庞大时，从开发到运维都将无从下手。
无论RPC框架还是微服务框架都是为了将系统拆分，化整为零，便于管理。

## 8. 分布式缓存

在分布式时代，分布式缓存可以说是让分布式更加高性能的一大助力之一，因为它具备**快**这个特性。
其一，读多写少的场景，完全可以将DB中的数据缓存一份，这样减少了DB的压力。
其二，可以作为限流的辅助，比如单用户10s之内不允许重复操作。
其三，Redis也是常用的分布式锁的实现方式之一。

## 9. 分布式消息队列

分布式消息队列是让分布式更加高性能的另一大助力。因为它具备**解耦**这个特性。
虽然分布式框架提供了远程过程调用，但是这是同步操作的，也就是你不可预知我调用了这个接口啥时候才能拿到结果（处理就是满、网络也有可能影响等等），
那对于一些有低延迟要求的操作将是毁灭的，而很多时候其实调用方并不是严格一定要立马就拿到结果的，
这时候完全可以丢给队列通知对方操作。